# check fitness
checkFit <- function(st = gen.dt, strat, nmoves = 200, times = 100){
## evaluates the strategy and returns a numeric score
# append strategy to state list
st[, strategy := strat]
# initalize score
score <- 0
for(i in 1:times){
# make a grid of 'cans', 10 x 10
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
pos = c(1, 1) # start positon for each trial
for(move in 1:nmoves){
cstate <- lookAround(can_grid, pos)
mv <- st[state == cstate, strategy]
switch(mv,
if(pos[1] == 1){ # move North
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[1] == 10){ # move South
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[2] == 10){ # move East
score = score - 5
} else {
pos[2] = pos[2]+1
},
if(pos[2] == 1){ # move West
score = score - 5
} else {
pos[2] = pos[2]-1
},
pos = pos, # random
pos = pos, # stay
if(can_grid[pos[1], pos[2]] == 3){ # pick up can
score = score + 10
can_grid[pos[1], pos[2]] <- 1 # set to empty
} else {
score = score - 1
}
) # end switch
} # end for loop
}
return(score)
}
s1 <- gen.dt$strategy
s1
s1 <- gen.dt[, sample(moves, nrow(gen.dt), replace = TRUE)]
s1
s1.fit <- checkFit(st = gen.dt, strat = s1, nmoves = 200, times = 10)
s1.fit
gen <- list()
for(i in 1:200){
# for the 200 individuals in the generation
gen[[i]] <- copy(gen.dt[, strategy := sample(moves, nrow(gen.dt), replace = TRUE)])
# have to copy or will change by reference
}
gen.fit <- lapply(gen, checkFit) # this is much faster than previous implementation
?is.na
gen.fit <- lapply(gen, checkFit(strat = strategy)) # this is much faster than previous implementation
checkFit <- function(st = gen.dt, strat, nmoves = 200, times = 100){
## evaluates the strategy for <nmoves> moves over <times> iterations
# if strat is supplied, append strategy to state list
if(!is.na(strat)) st[, strategy := strat]
# initalize score
score <- 0
for(i in 1:times){
# make a grid of 'cans', 10 x 10
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
pos = c(1, 1) # start positon for each trial
for(move in 1:nmoves){
cstate <- lookAround(can_grid, pos)
mv <- st[state == cstate, strategy]
switch(mv,
if(pos[1] == 1){ # move North
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[1] == 10){ # move South
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[2] == 10){ # move East
score = score - 5
} else {
pos[2] = pos[2]+1
},
if(pos[2] == 1){ # move West
score = score - 5
} else {
pos[2] = pos[2]-1
},
pos = pos, # random
pos = pos, # stay
if(can_grid[pos[1], pos[2]] == 3){ # pick up can
score = score + 10
can_grid[pos[1], pos[2]] <- 1 # set to empty
} else {
score = score - 1
}
) # end switch
} # end for loop
}
return(score/times) # average over all iterations
}
gen.fit <- lapply(gen, checkFit(strat = NA)) # this is much faster than previous implementation
strat = NA
is.na(start)
is.na(strat)
checkFit <- function(st = gen.dt, nmoves = 200, times = 100){
## evaluates the strategy for <nmoves> moves over <times> iterations
# initalize score
score <- 0
for(i in 1:times){
# make a grid of 'cans', 10 x 10
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
pos = c(1, 1) # start positon for each trial
for(move in 1:nmoves){
cstate <- lookAround(can_grid, pos)
mv <- st[state == cstate, strategy]
switch(mv,
if(pos[1] == 1){ # move North
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[1] == 10){ # move South
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[2] == 10){ # move East
score = score - 5
} else {
pos[2] = pos[2]+1
},
if(pos[2] == 1){ # move West
score = score - 5
} else {
pos[2] = pos[2]-1
},
pos = pos, # random
pos = pos, # stay
if(can_grid[pos[1], pos[2]] == 3){ # pick up can
score = score + 10
can_grid[pos[1], pos[2]] <- 1 # set to empty
} else {
score = score - 1
}
) # end switch
} # end for loop
}
return(score/times) # average over all iterations
}
gen.fit <- lapply(gen, checkFit) # this is much faster than previous implementation
gen.fit
get.fit.dt
get.fit
gen.fit.dt
sum.fit
p
gen.fit
gen.fit.dt <- data.table(stratnum = 1:length(gen.fit), fitness = unlist(gen.fit))
gen.fit.dt
sum.fit <- gen.fit.dt[, sum(fitness)]
gen.fit.dt[, iprob := fitness/sum.fit] # as probabilities for selection
p <- gen.fit.dt[, sample(stratnum, 2, prob = iprob)] # nominate two parents based on fitness
gen.fit.dt[fitness < 0, fitness := 0] # set negatives to zero
gen.fit.dt[, fitness := fitness^2] # square the fitness values
sum.fit <- gen.fit.dt[, sum(fitness)]
gen.fit.dt[, iprob := fitness/sum.fit] # as probabilities for selection
p <- gen.fit.dt[, sample(stratnum, 2, prob = iprob)] # nominate two parents based on fitness
p
rm(list=ls())
library(data.table)
library(magrittr)
labels = c(1:3)
labels.names = c('empty', 'wall', 'can')
moves = c(1:7)
moves.names = c('move_N', 'move_S', 'move_E', 'move_W', 'move_R', 'stay_put', 'pick_up_can')
# build decision matrix
grid <- expand.grid(labels, labels, labels, labels, labels)
mult <- c(10000, 1000, 100, 10, 1)
grid <- t(t(grid) * mult)
states <- rowSums(grid)
gen.dt <- data.table(state = states)
gen.dt <- gen.dt[order(state)] # the list of states
# first strategy is randomly selected
s1 <- gen.dt[, sample(moves, nrow(gen.dt), replace = TRUE)]
# look around and determine the state of neighbors
lookAround <- function(can_grid, position){
sit_code = c(NA, NA, NA, NA, NA)
if(position[1] == 1){
sit_code[1] = 2
} else {
sit_code[1] = can_grid[position[1]-1, position[2]]
}
if(position[1] == 10){
sit_code[2] = 2
} else {
sit_code[2] = can_grid[position[1]+1, position[2]]
}
if(position[2] == 10){
sit_code[3] = 2
} else {
sit_code[3] = can_grid[position[1], position[2]+1]
}
if(position[2] == 1){
sit_code[4] = 2
} else {
sit_code[4] = can_grid[position[1], position[2]-1]
}
sit_code[5] = can_grid[position[1], position[2]]
return(as.numeric(paste(sit_code, collapse = '')))
}
# check fitness
checkFit <- function(st = gen.dt, nmoves = 200, times = 100){
## evaluates the strategy for <nmoves> moves over <times> iterations
# initalize score
score <- 0
for(i in 1:times){
# make a grid of 'cans', 10 x 10
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
pos = c(1, 1) # start positon for each trial
for(move in 1:nmoves){
cstate <- lookAround(can_grid, pos)
mv <- st[state == cstate, strategy]
switch(mv,
if(pos[1] == 1){ # move North
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[1] == 10){ # move South
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[2] == 10){ # move East
score = score - 5
} else {
pos[2] = pos[2]+1
},
if(pos[2] == 1){ # move West
score = score - 5
} else {
pos[2] = pos[2]-1
},
pos = pos, # random
pos = pos, # stay
if(can_grid[pos[1], pos[2]] == 3){ # pick up can
score = score + 10
can_grid[pos[1], pos[2]] <- 1 # set to empty
} else {
score = score - 1
}
) # end switch
} # end for loop
}
return(score/times) # average over all iterations
}
# make an entire generation of strategies
gen <- list()
for(i in 1:200){
# for the 200 individuals in the generation
gen[[i]] <- copy(gen.dt[, strategy := sample(moves, nrow(gen.dt), replace = TRUE)])
# have to copy or will change by reference
}
gen
checkFit
gen[1:2]
gen[[1]]
gen[[1]] %>% checkFit
gen[1:2] %>% lapply(checkFit)
can_grid
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
can_grid
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
rm(list=ls())
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
ls()
gen.dt <- data.table(state = states)
gen.dt
gen.dt <- data.table(state = states) %>% .[order(states)]
gen.dt
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
gen
gen
gen.fit <- lapply(gen, checkFit)
?
position
can_grid
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
can_grid
position = c(1,1)
lookAround
lookAround(can_grid, position)
can_grid(position[1]+1, position[1])
can_grid[position[1]+1, position[1]]
gen
gen.fit
checkFit <- function(st = gen.dt, nmoves = 200, times = 100){
## evaluates the strategy for <nmoves> moves over <times> iterations
# initalize score
score <- 0
for(i in 1:times){
# make a grid of 'cans', 10 x 10
can_grid <- sample(c(1, 3), 100, replace = TRUE)
dim(can_grid) <- c(10, 10) # in matrix format
pos = c(1, 1) # start positon for each trial
for(move in 1:nmoves){
cstate <- lookAround(can_grid, pos)
mv <- st[state == cstate, strategy]
switch(mv,
if(pos[1] == 1){ # move North
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[1] == 10){ # move South
score = score - 5
} else {
pos[1] = pos[1]+1
},
if(pos[2] == 10){ # move East
score = score - 5
} else {
pos[2] = pos[2]+1
},
if(pos[2] == 1){ # move West
score = score - 5
} else {
pos[2] = pos[2]-1
},
pos = pos, # random
pos = pos, # stay
if(can_grid[pos[1], pos[2]] == 3){ # pick up can
score = score + 10
can_grid[pos[1], pos[2]] <- 1 # set to empty
} else {
score = score - 1
}
) # end switch
} # end for loop
}
cat(".")
return(score/times) # average over all iterations
}
checkfit(gen[[200]])
checkFit(gen[[200]])
snowflake <- function(x){
print(paste("Doing a thing to", x))
checkFit(x)
}
snowflake(gen[[1]])
snowstate <- 1
print(snowstate)
snowstate <- 1
snowflake <- function(x){
print(snowstate)
checkFit(x)
snowstate <<- snowstate + 1
}
gen.fit <- lapply(gen, snowflake)
snowstate <- 1
snowflake <- function(x){
print(snowstate)
y <- checkFit(x)
snowstate <<- snowstate + 1
return(y)
}
gen.fit <- lapply(gen, snowflake)
gen[[50]]
position
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
gen
g2 <- newGen(gen)
g2
indices
gen.fit
new.gen <- list()
gen.fit <- lapply(gen, snowflake)
gen.fit.dt <- data.table(stratnum = 1:length(gen.fit), fitness = unlist(gen.fit))
gen.fit.dt[fitness < 0, fitness := 0] # set negatives to zero
gen.fit.dt[, fitness := fitness^2] # square the fitness values
sum.fit <- gen.fit.dt[, sum(fitness)]
gen.fit.dt[, iprob := fitness/sum.fit] # as probabilities for selection
indices <- seq(1, 200, 2)
for(i in 1:100){
p <- gen.fit.dt[, sample(stratnum, 2, prob = iprob)]
locus <- sample(2:242, 1)
p1 <- generation[[p[1]]]$strategy
p2 <- generation[[p[2]]]$strategy
new.gen[[indices[i]]]<- c(p1[1:locus], p2[(locus+1):243]) %>% sapply(green_ooze)
new.gen[[indices[i]+1]] <- c(p2[1:locus], p1[(locus+1):243]) %>% sapply(green_ooze)
}
ls()
newGen
sum.fit
states
gen
gen.fit
current.gen
g2
ls()
"{}".format("here")
sprintf("%f", "thing")
sprintf("%s", "thing")
snowstate
sprintf("[%s]...", snowstate)
sprintf("[%s]...", snowstate)
sprintf("[%s]...", snowstate); sprintf("Test")
cat(sprintf("%s", test))
cat(sprintf("%s", "test"))
cat(sprintf("%s", "test")); cat("teting")
cat(sprintf("[%s]...", snowstate))
y <- checkFit(x)
cat(sprintf("[%s]...", snowstate))
cat(sprintf("[%s]...", snowstate))
cat(sprintf("[%s]...", snowstate))
cat(sprintf("[%s]...", snowstate)); cat(sprintf("[%s]...", snowstate))
ls()
new.gen
newGen
sum.fit
gen
generation
generation = gen
gen.fit.df
gen.fit.dt
gen.fit
gen.fit.dt[fitness < 0, fitness := 0.01] # set negatives to 0.01
gen.fit.dt[, fitness := fitness^2] # square the fitness values
sum.fit <- gen.fit.dt[, sum(fitness)]
sum.fit
gen.fit
gen.fit
gen.fit.dt <- data.table(stratnum = 1:length(gen.fit), fitness = unlist(gen.fit))
gen.fit.dt
gen.fit.dt[fitness < 0, fitness := 0.01] # set negatives to 0.01
gen.fit.dt[, fitness := fitness^2] # square the fitness values
sum.fit <- gen.fit.dt[, sum(fitness)]
gen.fit.dt[, iprob := fitness/sum.fit] # as probabilities for selection
indices <- seq(1, 200, 2)
p <- gen.fit.dt[, sample(stratnum, 2, prob = iprob)]
locus <- sample(2:242, 1)
p1 <- generation[[p[1]]]$strategy
p2 <- generation[[p[2]]]$strategy
p1
p2
gen
gen.dt
new.gen[[indices[i]]] <- data.table(state = gen.dt$state, strategy = c1)
c1 <- c(p1[1:locus], p2[(locus+1):243]) %>% sapply(green_ooze)
c1
data.table(state = gen.dt$state, strategy = c1)
rm(list = ls())
ls()
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
ls()
fitness <- data.table(generation = NA, fitness = NA)
fitness
current_gen = 1
testfn <- function(x){
fitness[1, fitness = 1]
}
testfn()
fitness
fitness <- data.table(generation = NA, score = NA) # for recording fitness across generations
fitness[1, score := 1]
fitness
fitness <- data.table(generation = NA, score = numeric()) # for recording fitness across generations
fitness <- data.table(generation = NA, score = NA # for recording fitness across generations
fitness <- data.table(generation = NA, score = NA) # for recording fitness across generations
fitness[1, score := 1.2]
fitness
str(fitness)
?data.table
fitness <- data.table(generation = numeric(current_gen), score = numeric(NA)) # for recording fitness across generations
current_gen = 1 # iterator for generation
fitness <- data.table(generation = numeric(current_gen), score = numeric(NA)) # for recording fitness across generations
fitness <- data.table(generation = numeric(current_gen), score = numeric()) # for recording fitness across generations
fitness <- data.table(generation = numeric(current_gen), score = NA_integer_) # for recording fitness across generations
fitness
current_gen = 1 # iterator for generation
fitness <- data.table(generation = numeric(current_gen), score = NA_integer_) # for recording fitness across generations
fitness
fitness <- data.table(generation = current_gen, score = NA_integer_) # for recording fitness across generations
str(fitness)
fitness[1, score := 1.2]
fitness
current_gen = 1 # iterator for generation
fitness <- data.table(generation = current_gen, score = NA_integer_) # for recording fitness across generations
testfn <- function(x){
fitness[1, score = 1234]
}
testfn()
rm(list=ls())
source('C:/Users/chris/Documents/GitHub/cas/robby2.R', echo=TRUE)
gen.bank[[2]]
gen.fit
